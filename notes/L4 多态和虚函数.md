## L4 多态和虚函数

#### 1.虚函数声明

virtual关键字，只用在类定义里的函数声明中，写函数体时不用

#### 2.多态

##### 前置知识

1.派生类的地址可以赋给基类指针（派生类前面也是基类，但是会损失派生部分）

如果基类指针指向的是一个派生类对象，那么可以通过强制类型转换把基类指针变成派生类指针。

2.派生类的对象可以赋给基类对象（损失派生部分）

3.派生类的对象可以初始化基类引用（损失派生部分）

##### 表现形式

###### 1.指针指什么，而忽略指针类型

基类指针可能指着一个派生类对象或者一个基类对象

当用基类指针调用基类和派生类中同名同参的虚函数时，这个指针指哪种类，就调用这个类的虚函数

###### 2.引用了什么，而忽略引用类型

基类引用可能引用的是派生类对象或者基类对象

当用基类引用调用基类和派生类中同名同参的虚函数时，这个引用引用哪种类，就调用这个类的虚函数

##### 作用：可扩充性

用基类指针数组存放各种派生类对象的指针然后遍历该数组对各个派生类对象操作

##### tips

1.在非构造函数和非析构函数中调用虚函数是多态，相当于this->虚函数，但是在构造函数和析构函数中调用虚函数是多态。

2.派生类中和基类的虚函数同名同参数表的函数，不加virtual也自动成为虚函数

3.尽管有多态，但是在编译的时候不考虑运行结果

也就是说，如果基类的虚函数是private的话，即使派生类虚函数变成Public的也不能通过一个指向派生类对象的基类指针调用这个虚函数

但是若基类虚函数是public但是派生类函数是private就可以

#### 3.多态实现原理：动态联编

有虚函数的类有一个**虚函数表**，列出了该类的虚函数地址

该类的任何对象中都放着虚函数表的指针

基类指针指向派生类对象的时候，虚函数表属于派生类！

#### 4.虚析构函数

基类指针想要删除派生类对象，只调用基类析构函数，删不干净。

应该把基类的析构函数virtual

一个类如果有虚函数或者一个类是基类，那么析构函数应该是虚函数

#### 5.纯虚函数与抽象类

纯虚函数：没有函数体的虚函数

```C++
virtual void f()=0;
```

抽象类：包含纯虚函数的类，只能做基类，不能创建对象，但可以创建指针和引用

抽象类的成员函数内部可以调用纯虚函数，构造函数或析构函数内部不行

从抽象类派生来的派生类要实现基类中所有的纯虚函数才能成为非抽象类

