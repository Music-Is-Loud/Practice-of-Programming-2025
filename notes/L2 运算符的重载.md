## 运算符的重载

#### 1.目的

对一些抽象数据类型（自定义数据类型）也能直接使用C++提供的运算符。

对已有运算符赋予多重含义，使同一运算符作用于不同类型的数据时导致不同类型的行为

Eg. (5,10i)+(4,8i)=(9,18i)   5+4=9

这两处+的含义是不同的

**！重载运算符（）[] -> =都必须声明为类的成员函数**

**不允许重载运算符都不作用于对象！**

**不允许重载.  ::  ?:  sizeof**

#### 2.声明

返回值类型 operator 运算符（形参表）

{

}

运算符表达式变为运算符函数的调用

运算符操作数变为运算符函数的参数

多次重载根据实参类型决定调用哪个

返回值类型最好是保留运算符原本的特性

#### 3.参数个数

可以被重载成普通函数也可以是类的成员函数

重载为成员函数，参数个数要-1（比运算符目数少一），默认第一个参数是类的对象本身

重载成普通函数，参数个数不变（等于运算符目数）

```C++
class Complex
{
		public:
			double real,imag;
			Complex(double r=0.0,double i=0.0):real(r),image(i)
			{}//这里自动赋值了
			Complex operator-(const Complex &c);
			//类内定义，重载为成员函数
};
Complex operator+(const Complex &a,const Complex &b)
{
	 return Complex(a.real+b.real,a.imag+b.imag);
}//类外定义，重载为普通函数
Complex Complex::operator-(const Complex &c)
{
		return Complex(real-c.real,imag-c.imag);
}//类内定义，成员函数包含this指针，调用对象
//c=a-b等价于a.operator-(b)
```



#### 4.赋值运算符‘=’的重载

只能重载为成员函数

此处=用于赋值而不是用于初始化！

###### 浅复制和深复制

浅复制：直接将两个指针指到一起

深复制：改变指针指向的内容

###### 等号顺序

```C++
a=b=c;//a.operator=(b.operator=(c));从右往左
(a.operator=(b)).operator=(c);
```

#### 5.流输入运算符的重载

cout是iostream中定义的ostream类对象

<<用在cout上是因为iostream对<<进行了重载

```C++
friend ostream& operator <<(ostream& o,MyString& s)
{
    o<<s.p;
    return o;
}
//重载为全局函数（friend友元但是内联函数），能够cout<<s 注意顺序
//如果重载为成员函数，只能s<<cout 不符合习惯
```



#### 6.重载类型转换运算符

operator int()

必须为成员函数，无返回类型（实际上就是int等的返回类型），形参为空，类转换自动调用

```C++
(int) s;//等效于s.int()
```



#### 7.自增自减运算符重载

前置运算符做一元运算符重载

先修改，再返回

直接返回实际对象（引用）

```C++
T& operator++()//成员函数
T& operator++(T2 t)//普通函数
  
++obj;
obj.operator++();
operator++(obj);
```

后置运算符做二元运算符重载，多写一个没用的参数

先返回（一个临时参数，不是引用），后修改

返回一个临时对象

```C++
T operator++(int)//成员函数
T operator++(T1 t,int)//普通函数
  
obj++;
obj.operator++(0);
operator++(obj,0);
```
