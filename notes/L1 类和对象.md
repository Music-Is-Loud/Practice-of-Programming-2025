# 类和对象



### 面向对象的基本概念

##### 1.访问权限

在类成员函数内部可以访问当前对象和同类对象的全部属性和函数

在类成员函数外的地方只能访问类对象的公有成员。

class默认私有，struct默认公有

##### 2.如何使用类的成员变量和成员函数

2.1对象名.成员名

2.2指针->成员名

```C++
CRectangle r1,r2;
CRectangle * p1=&r1;
p1->w=5;
p1->Init(3,4);
//w和Init都是CRectangle里的成员
```

2.3 引用名.成员名

```C++
CRectangle r2;
CRectangle & rr=r2;
```



### 构造函数

成员函数的一种，用于初始化对象，如给成员变量赋值

##### 1.声明

一个类里面可以有多个

```C++
class Complex
{
  private:
  	double real,imag;
	public:
  	Complex(double r,double i=0);
}
Complex::Complex(double r,double i)
{
  real=r;imag=i;
}
Complex c1(2);//参数缺省
Complex c2(2,4);
Complex *pc=new Complex(3,4);//申请指针也要执行，带参数
```

允许重载

最好是public的，private的构造函数不能初始化对象，会报错

##### 2.调用

不写的话，默认生成无参数的构造函数

对象生成时自动调用，一旦生成不能再执行

建立对象数组，每个元素都要调用一次

```C++
Test a[5]={1,Test(1,2),Test(1),(1,2)};
//此处a[0]和a[2]的初始化方式一样，都是Test一个参数初始化，调用只有一个参数的构造函数
//a[1]是两个参数的初始化
//a[3]括号表达式，取2，调用只有一个参数的构造函数
//a[4]调用无参数的构造函数
```



### 复制构造函数

##### 1.声明

只有一个参数，该参数是对同类对象的引用

```C++
X::X(X&);
X::X(const X&);
X::X(X);//不允许！
```

##### 2.调用

不写的话，默认生成复制构造函数，完成的是复制功能。

注意！

复制构造函数属于构造函数的一种。

一旦写了复制构造函数，编译器将不再生成默认的初始化构造函数。

```C++
class Complex
{
    public:
        double real,imag;
        Complex(Complex &c);//复制构造函数
};
Complex::Complex(Complex &c)
{
    real=c.real;
    imag=c.imag;
}
Complex c1;//报错
Complex c2(c1);//正确
```

若什么构造函数都不写或只写了初始化构造函数，下面两行才正确



###### 调用情形：

**a.**用一个对象去初始化同类的另一个对象

```C++
Complex c2(c1);//初始化语句调用！
Complex c2=c1;//初始化语句而非赋值语句！
```

**b.**函数有一个参数是类的对象，该函数被调用时，类的复制构造函数将也被调用。

**注**：为了避免调用时生成形参引发复制构造函数的调用（开销比较大），用X& 引用类型作为参数。为防止实参被改变，加上const关键字。

**c.**函数的返回值是类A的对象，函数返回时A的复制构造函数也被调用

**！**对象间用等号赋值不导致复制构造函数被调用



### 类型转换构造函数

实现类型的自动转换

##### 1.声明

只有一个参数

##### 2.调用

需要时编译系统会自动调用转换构造函数，建立一个无名的临时对象。

```C++
class Complex
{
    public:
        double real,imag;
        Complex(int i)//类型转换构造函数
        {
        	  real=i;image=0;
        }
        Complex(double r,double i)//构造函数
        {
        	real=r;imag=i;
				}
        
};
Complex c1(7,8);
Complex c2=12;//正确，是初始化，调用类型转换构造函数
//但是加了explicit后要用Complex（12）
c1=9;
//在main函数中正确,因为main函数知道是在改变值；
//但是对全局变量操作，编译器以为你在重新初始化，产生了二义性
//在main函数中直接赋值是可以的，会自动生成赋值=的重载，把所有能赋值的都赋值了(在只有一个参数作为构造函数的情况下，否则仍然报错)
```

explicit防止显式类型自动转换。



##### Tips:关于臭名昭著的直接赋值

在上述代码段中的最后两行就是臭名昭著的直接赋值，以倒数第二行为例

有explicit以后就可以很好地防止这种流氓行为

在没有explicit的时候：

（1）等号右边的数被调用构造函数成为了一个临时对象

（2）使用复制构造函数给c2初始化，此例中没有复制构造函数，使用系统默认的；

（3）析构函数使临时对象消亡



若写了复制构造函数，则需要注意以下两点：

（2.1）const修饰

（对部分编译器而言）

例如，我现在写了这样一个拷贝构造函数。

```C++
Complex(Complex& complex)
{
        cout << "Complex copy constructor called" << endl;
}
```

这会导致报错，因为对于

```C++
Complex c2=12;
```

这个语句，右边是由常数生成的临时对象，是常量对象。所以拷贝构造函数的参数必须是该类的常对象。需要修改为

```C++
Complex(const Complex& complex)
{
        cout << "Complex copy constructor called" << endl;
}
```

（2.2）编译器的自动优化。

事实上，不自己写拷贝构造函数就不会报错。

这是因为编译器会优化掉（不使用）不必要的拷贝构造（例如你写的），但是你写的拷贝构造在检查语法的时候仍然会被检查到（编译的时候不会生成默认的拷贝构造函数，只会使用你写的拷贝构造函数）。

写上以后仍然不调用这个（因为不必要），只是编译可以通过。





### 析构函数

对对象消亡之前做最后的善后工作

##### 1.声明

无参数返回值，名字与类名相同，在前面加～

一个类最多只有一个

如果定义类的时候没写，编译器生成缺省析构函数，缺省析构函数什么也不做

##### 2.调用

析构函数对象消亡时自动调用

**2.1**对象数组生命周期结束时（return 0;new指针之后delete，不delete不调用；正常参数消亡；在花括号中），对象数组每个元素的析构函数都会被调用

**2.2**在对象作为函数返回值（临时对象）返回后自动被调用

**2.3**参数对象消亡也会导致析构函数被调用

消亡顺序：返回值临时对象-局部-static-全局



### this 指针

指向成员函数所作用的对象

一般成员函数默认第一个参数是该类类型的指针this

非静态成员函数中可以直接使用this来代表指向该函数作用对象的指针



### 静态成员

与某些类紧密相关的全局变量写进类里封装，便于维护和理解

##### 1.声明

说明前面加static

定义类定义的外面专门对静态成员变量进行声明并初始化

##### 2.特殊性（可看作全局变量）

2.1一个类的静态成员为所有对象共享

2.2不需要通过对象访问

2.3不被sizeof计算

2.4静态成员函数也不会作用于某个特定对象

2.5哪怕一个类没有对象，他们也存在

2.6（与全局变量的不同之处）如果静态成员变量是私有，那么仍然无法直接访问

2.7 静态成员函数不能访问非静态成员变量（不知道是谁的），也不能调用非静态成员函数，没有this指针也不会默认有this指针的参数

##### 3.调用

3.1类名：：成员名

3.2和普通成员一样



### 常量对象和常量方法

##### 1.常量对象

只能使用：构造函数，析构函数和有const说明的函数（常量方法）

##### 2.常量成员函数：

**2.1 声明：**

类的成员函数说明**后**加const关键字，定义声明都要

**2.2 性质：**

2.2.1 常量成员函数内部不可以改变非静态属性的值，只能改变有**mutable**关键字修饰的成员变量

2.2.2 不能调用同类非常量成员函数（除了静态成员函数）

**2.3 特殊说明**

函数一模一样除了const与否，算作重载



### 成员对象与封闭类

成员对象：一个类的成员变量是另一个类的对象

封闭类：有成员对象的类

##### 1.封闭类的声明

必须有构造函数（不能用默认的），否则编译器不知道怎么成员对象初始化

定义封闭类的构造函数：添加初始化列表

初始化const成员和引用成员必须在成员初始化列表中进行

类名::构造函数(参数表):成员变量1(参数表)，成员变量2(参数表)



```C++
class CCar
{
	int price;CEngine engine;Ctyre tyre;
	public:
		CCar(int p,int tr,int tw,int eNum);//构造
		~CCar(){};//析构
};
CCar::CCar(int p,int tr,int tw,int eNum):price(p),tyre(tr,tw),engine(eNum)
{
};//构造函数，p属于price,tr和tw属于tyre，eNum属于engine
//本质上，参数列表是在对成员对象进行初始化（对成员参数亦然），故成员对象所属的类
//在本例中是Ctyre和CEngine分别需要有一个参数和两个参数的初始化构造函数

```

##### 2.调用顺序

**2.1封闭类对象生成**

（按照类中的说明次序）成员对象构造函数----->封闭类构造函数

**2.2 封闭类对象消亡**

与构造函数调用次序相反

##### 3.封闭类的复制构造函数

如果封闭类对象用默认复制构造函数初始化

那么这个对象里面包含的成员对象也用复制构造函数初始化而非朴素的初始化构造函数



### 友元

##### 1.友元函数

一个类的友元函数可以访问该类的私有成员

该函数不一定是在这个类里的，所以原来未必可以访问私有成员，除非设置成了友元

可以将一个类的成员函数（包括构造与析构）说明为另一个类的友元

```C++
friend int A::f();
//friend+函数类型+函数所属的类（自己就不用写）+函数名
```

##### 2.友元类

A是B的友元类，A的成员函数可以访问B的私有成员

```C++
class A
{
		friend void B::funciton();//把一个类的成员函数说明为另一个类的友元
  	friend class C;//声明C为友元类
}
```

不能传递不能继承
